
Семин
Создать package – animals. Работу продолжаем в нем
Создать абстрактный класс Animal с полями год рождения, вес, кол-во
конечностей
Реализовать наследников класса Animal классы Lion и Snake, добавив к ним по
одному доп. полю объем гривы и длина тела соответственно.
4. Реализовать метод кормления void feed(int foodWeight), после которого вес
животного увеличивается.


Создать в классе Lion и Snake статичные финальные поля MAX_WEIGHT и TYPE и на
той же строке объявления присвоить им значения.
Добавить логику в метод feed, чтобы животное не могло превысить свой
максимальный вес.
3. Реализовать логику так, чтобы метод feed находился в классе Animal и
использовал внутри себя абстрактный метод


Создать package – factory. Работу продолжаем в нем
Создать класс LionsFactory
Реализовать в нем статический метод для создания коллекции львов с определенным кол-вом в ней:
ArrayList<Lion> createLions (int lionCount)
В методе main создать коллекцию львов и положить её содержимое в клетку. Посмотрите состояние львов, покормите львов в клетке, проверьте изменился ли у них вес.

Создать класс LionComporator, реализующий интерфейс Comparator<Lion>
Реализовать контракт compare() со сравнением по объему гривы
Модифицировать класс LionCage, добавив в него метод сортировки львов по гриве 
    
Модифицировать класс Lion, заставив его реализовать интерфейс
Comparable<Lion>
Реализовать контракт compareTo () со сравнением по возрасту льва
Добавить класс LionCage метод сортировки львов по возрасту
void sortLions()
     
Создать package – cage. Работу продолжаем в нем
Создать интерфейс AnimalCage, который содержит абстрактные методы для:
добавления в клетку животного
передачи корма в клетку
очистку клетки
Создать для сущности Lion отдельный LionCage, реализующий интерфейс
AnimalCage. В клетке должна хранится информация о находящихся в ней львах и
объем загрязнения клетки.

Дз - 2:
Создать класс Wolf, наследника класса Animal.
Создать класс WolfCage, имплементирующий интерфейс AnimalCage
Добавить абстрактный метод в интерфейс AnimalCage, достающий первое попавшееся животное из клетки.
Все вышеуказанное создать согласно принципам ООП пройдённым на семинаре

Дз - 3:
Создать класс WolfComparator, реализующий сравнение волков по их весу и возрасту.
В классе WolfCage добавить метод сортировки волков, используя созданный WolfComparator
Имплементировать в классе WolfCage интерфейс Iterable<Wolf> и реализовать логику итерации по волкам в клетке с помощью класса WolfIterator

Семинар 4:
1)
- Обобщить интерфейс AnimalCage, добавив к имени интерфейса “<T>”
- Сделать так, чтобы абстрактные методы использовали дженерик T
- Проанализировать изменения в классах, реализующих AnimalCage

something info:

Wildcard - это подстановочный символ обозначающий неизвестный тип данных
<T extends Class1>
<T super Class2>
<T> - Diamond оператор
по предку:
ClassArrays<? extends Number> byteArray = new ClassArrays<Byte>();

по наследнику:
ClassArrays<? super Number> byteArray = new ClassArrays<Byte>();

без ограничений:
ClassArrays<?> byteArray = new ClassArrays<Byte>();

2)
- Обобщить интерфейс AnimalCage так, 
чтобы он работал только с наследниками класса Animal, 
добавив к имени интерфейса “<T extends>”

3)
- Создать пэкедж zoo, работу продолжаем в нём
- создать класс Zoo и объявить у него 3 переменные:
клетка с волками
клетка с львами
террариум со змеями
-использовать тип переменных как можно более абстрактный

4)
- Создать пэкедж animalUtils, работу продолжаем в нём
- создать класс AnimalUtils и реализовать в нём статический метод 
для сортировки списка животных по возрасту
<T extends Animal> List<T> sortAnimals (List<T> animalList)

ДЗ - 4:
Выполнить все задания из семинара 4
Имплементировать обобщенный интерфейс AnimalCage в классах SnakeCage и WolfCage
Переписать классы из ДЗ1 с использование дженериков

Семинар 5
- Создать пекедж terminal. Дальнейшие работы ведем в нем
- Создать интерфейс CommandParser c методом String[] parseCommand (String inputCommand)
- Создать класс TerminalReader, который содержит переменную CommandParser и метод, 
который в бесконечном цикле слушает команды с помощью Scanner(System.in)

домой:
- Создать интерфейс CommandExecutable c абстрактным методом execute()
- Реализовать 2 класса, имплементировав созданный интерфейс, 
CreateLionExecutable и DeleteLionExecutable. 
В унаследованных методах они должны обращаться
к методом класса LionCage объекта Zoo.
- Подумать какие переменные могли бы содержать созданные классы


Повторить функционал с семинара №5
Создать класc CommandExecutableFactory
- Реализовать в нём метод CommandExecutable create (String[] input), 
где в зависимости от переданных параметров создается тот или иной класс
- дописать тело метода endless() класса TerminalReader, 
так чтобы введенная команда парсилась, 
на результате парсинга создавался объект CommandExecutable
и вызывался метод execute()

доделать
- Создать класс Command, который бы инкапсулировал 
в себе содержимое введенной команды
- Изменить сигнатуру у интерфейса ParseCommand, 
чтобы он вместо массива строк начал возвращать объект класса Command
- Реализовать в нем булевские методы для проверки введенных команд
- отредактировать класс CommandExecutableFactory, 
убрав из него хардкод и начав принимать на вход объект Command


- Создать класс LogingCommandExecutableFactory, 
наследующий класс CommandExecutableFactory 
- Переопределить единственный метод так, 
чтобы он вызывал внутри себя метод предка, 
но в начале и конце распечатывал информацию 
о входных и выходных параметрах


доделать
- Переименовать класс  CommandExecutableFactory 
в CommandExecutableFactoryImpl  
- Создать интерфейс CommandExecutableFactory 
и имплементировать от него класс CommandExecutableFactoryImpl.
- В классе TerminalReader реализовать DIP, 
то есть возможность менять реализации CommandExecutableFactory